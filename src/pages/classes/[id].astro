---
import Layout from '../../layouts/Layout.astro';
import ClassTable from '../../components/classes/ClassTable.astro';
import { classes } from '../../data/classes';
import { spells } from '../../data/spells';

export function getStaticPaths() {
  return classes.map(classData => ({
    params: { id: classData.id },
    props: { classData }
  }));
}

const { classData } = Astro.props;

// Функция для преобразования текстовой таблицы в структурированные данные
function parseTableData(text: string) {
  const rows = text.split('\n').filter(row => row.trim());
  return rows.map(row => {
    const [level, spells] = row.split('\t');
    return { level, spells };
  });
}
---

<Layout title={`${classData.name}`}>
  <div class="content">
    <a href="/classes" class="back-link">← Назад к классам</a>

    <div class="class-header">
      <h1>{classData.name} <span class="name-en">[{classData.nameEn}]</span></h1>
      <div class="source">{classData.sourceBook}</div>
    </div>

    <div class="class-description">
      <div class="subclass-selector">
        <select id="subclass-select">
          <option value="">Выберите подкласс</option>
          {classData.subclasses.map(subclass => (
            <option value={subclass.id}>{subclass.name} [{subclass.nameEn}]</option>
          ))}
        </select>
      </div>

      <div id="class-lore" class="lore-content">
        <p>{classData.description}</p>
      </div>

      <details id="base-lore" class="base-lore" style="display: none;">
        <summary>Основное описание класса</summary>
        <p>{classData.description}</p>
      </details>
    </div>

    <div class="class-basics">
      <div class="basic-info">
        <h2>Основные характеристики</h2>
        <dl>
          <dt>Основная характеристика</dt>
          <dd>{classData.primaryAbility}</dd>

          <dt>Кость хитов</dt>
          <dd>к{classData.hitDice}</dd>

          <dt>Хиты на 1 уровне</dt>
          <dd>{classData.hitPoints.level1}</dd>

          <dt>Хиты на следующих уровнях</dt>
          <dd>{classData.hitPoints.higherLevels}</dd>
        </dl>
      </div>

      <div class="proficiencies">
        <h2>Владения</h2>
        <dl>
          <dt>Доспехи</dt>
          <dd>{classData.proficiencies?.armor?.join(', ') || 'Нет'}</dd>

          <dt>Оружие</dt>
          <dd>{classData.proficiencies?.weapons?.join(', ') || 'Нет'}</dd>

          <dt>Спасброски</dt>
          <dd>{classData.proficiencies?.savingThrows?.join(', ') || 'Нет'}</dd>

          <dt>Навыки</dt>
          <dd>Выберите {classData.proficiencies.skills.count} из: {classData.proficiencies?.skills?.list?.join(', ') || 'Нет'}</dd>

          <dt>Инструменты</dt>
          <dd>{classData.proficiencies?.tools?.join(', ') || 'Нет'}</dd>
        </dl>
      </div>
    </div>

    <div class="equipment">
      <h2>Стартовое снаряжение</h2>
      <p>Выберите один из следующих наборов:</p>

      {classData.equipment.default.map(choice => (
        <div class="equipment-choice">
          <h3>Вариант {choice.choice}</h3>
          <ul>
            {choice.items.map(item => (
              <li>{item}</li>
            ))}
          </ul>
        </div>
      ))}
    </div>

    <div class="class-progression">
      <h2>Развитие класса</h2>
      <ClassTable levels={classData.levels} />
    </div>

    <div id="features-container" class="class-features">
      <h2>Умения класса</h2>
      {classData.features.map(feature => (
        <div class="feature">
          <div class="feature-header">
            <h3>{feature.name}</h3>
            <span class="feature-level">{feature.level} уровень</span>
          </div>
          <div class="feature-description">
            {feature.description.split('\n').map(paragraph => (
              <p set:html={paragraph}></p>
            ))}
            
            {feature.collapsible && (
              <div class="collapsible-content">
                {feature.collapsible.map(item => (
                  <details class="collapsible-item">
                    <summary>{item.title}</summary>
                    <div class="collapsible-description">
                      {item.description.split('\n').map(paragraph => (
                        <p>{paragraph}</p>
                      ))}
                    </div>
                  </details>
                ))}
              </div>
            )}
          </div>
        </div>
      ))}
    </div>

    <!-- Контейнер всплывающего окна заклинания -->
    <div id="spell-tooltip" class="hidden"></div>

    <template id="feature-template">
      <div class="feature">
        <div class="feature-header">
          <h3></h3>
          <span class="feature-level"></span>
        </div>
        <div class="feature-description"></div>
      </div>
    </template>

    <button id="scroll-to-top" class="scroll-to-top" aria-label="Прокрутить наверх">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="m18 15-6-6-6 6"/>
      </svg>
    </button>
  </div>
</Layout>

<script define:vars={{ classData }}>
  import { spells } from '../../data/spells';

  document.addEventListener('DOMContentLoaded', () => {
    const subclassSelect = document.getElementById('subclass-select');
    const classLore = document.getElementById('class-lore');
    const baseLore = document.getElementById('base-lore');
    const featuresContainer = document.getElementById('features-container');
    const featureTemplate = document.getElementById('feature-template');
    const tooltip = document.getElementById('spell-tooltip');
    let currentSubclass = null;

    // --- ФУНКЦИИ ИЗ ОРИГИНАЛА (создание таблиц, подклассов, скролл и т.д.) ---
    function createTableElement(tableText) {
      const rows = tableText.split('\n').filter(row => row.trim());
      const table = document.createElement('table');
      table.className = 'spell-table';

      const hasHeaders = rows.length > 1 && (
        rows[0].includes('\t') ||
        rows[0].split(/\s{2,}/).length > 1
      );

      if (hasHeaders) {
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        const headers = rows[0].includes('\t')
          ? rows[0].split('\t')
          : rows[0].split(/\s{2,}/);

        headers.forEach(header => {
          const th = document.createElement('th');
          th.textContent = header.trim();
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        rows.slice(1).forEach(row => {
          const tr = document.createElement('tr');
          const cells = row.includes('\t')
            ? row.split('\t')
            : row.split(/\s{2,}/);

          cells.forEach(cell => {
            const td = document.createElement('td');
            td.textContent = cell.trim();
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
      } else {
        const tbody = document.createElement('tbody');
        rows.forEach(row => {
          const tr = document.createElement('tr');
          const cells = row.includes('\t')
            ? row.split('\t')
            : row.split(/\s{2,}/);
          cells.forEach(cell => {
            const td = document.createElement('td');
            td.textContent = cell.trim();
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
      }

      return table;
    }

    function createFeatureElement(feature, isSubclassFeature = false) {
      const template = featureTemplate.content.cloneNode(true);
      const featureElement = template.querySelector('.feature');

      if (isSubclassFeature) {
        featureElement.classList.add('subclass-feature');
      }

      featureElement.querySelector('h3').textContent = feature.name;
      featureElement.querySelector('.feature-level').textContent = `${feature.level} уровень`;
      const descriptionContainer = featureElement.querySelector('.feature-description');

      if (feature.collapsible) {
        const collapsibleContent = document.createElement('div');
        collapsibleContent.className = 'collapsible-content';

        feature.collapsible.forEach(item => {
          const details = document.createElement('details');
          details.className = 'collapsible-item';

          const summary = document.createElement('summary');
          summary.textContent = item.title;
          details.appendChild(summary);

          const description = document.createElement('div');
          description.className = 'collapsible-description';

          if (item.tableData) {
            const table = document.createElement('table');
            table.className = 'spell-table';

            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            item.tableData.headers.forEach(header => {
              const th = document.createElement('th');
              th.textContent = header;
              headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            item.tableData.rows.forEach(row => {
              const tr = document.createElement('tr');
              row.forEach(cell => {
                const td = document.createElement('td');
                td.textContent = cell;
                tr.appendChild(td);
              });
              tbody.appendChild(tr);
            });
            table.appendChild(tbody);

            description.appendChild(table);
          } else {
            item.description.split('\n').forEach(paragraph => {
              const p = document.createElement('p');
              p.textContent = paragraph;
              description.appendChild(p);
            });
          }

          details.appendChild(description);
          collapsibleContent.appendChild(details);
        });

        descriptionContainer.appendChild(collapsibleContent);
      } else if (feature.name.toLowerCase().includes('таблица')) {
        const table = createTableElement(feature.description);
        descriptionContainer.appendChild(table);
      } else {
        feature.description.split('\n').forEach(paragraph => {
          const p = document.createElement('p');
          p.textContent = paragraph;
          descriptionContainer.appendChild(p);
        });
      }

      return featureElement;
    }

    function updateFeatures(subclassId) {
      if (!featuresContainer || !featureTemplate) return;

      let features = [...classData.features];
      if (subclassId) {
        const subclass = classData.subclasses.find(s => s.id === subclassId);
        if (subclass) {
          const subclassLevels = new Set(subclass.features.map(f => f.level));
          features = features.filter(f => {
            if (!subclassLevels.has(f.level)) return true;
            if (f.name.includes('Подкласс') || f.name.includes('Круг') ||
                f.name.includes('Домен') || f.name.includes('Путь')) {
              return false;
            }
            return true;
          });
          features = [...features, ...subclass.features];
        }
      }

      features.sort((a, b) => a.level - b.level);
      const title = featuresContainer.querySelector('h2');
      featuresContainer.innerHTML = '';
      featuresContainer.appendChild(title);

      features.forEach(feature => {
        const isSubclassFeature = subclassId && classData.subclasses
          .find(s => s.id === subclassId)?.features
          .some(f => f.name === feature.name);
        const featureElement = createFeatureElement(feature, isSubclassFeature);
        featuresContainer.appendChild(featureElement);
      });
    }

    // Инициализация подсказок-заклинаний (hover preview)
    function initializeSpellTooltips() {
      const links = document.querySelectorAll('a[data-spell-id]');
      links.forEach(link => {
        link.addEventListener('mouseenter', event => {
          const id = event.target.dataset.spellId;
          const spell = spells.find(s => s.id === id);
          if (!spell) return;

          tooltip.innerHTML = `
            <h3>${spell.name} <span style="opacity:0.6;">[${spell.nameEn}]</span></h3>
            <p><strong>${spell.level === 'cantrip' ? 'Заговор' : spell.level + ' уровень'}</strong>, ${spell.school}</p>
            <p><em>${spell.castingTime}</em> — ${spell.range}</p>
            <div>${spell.description}</div>
          `;

          const rect = event.target.getBoundingClientRect();
          tooltip.style.top = `${rect.bottom + window.scrollY + 6}px`;
          tooltip.style.left = `${rect.left + window.scrollX}px`;
          tooltip.classList.remove('hidden');
        });

        link.addEventListener('mouseleave', () => {
          tooltip.classList.add('hidden');
        });
      });
    }

    // запуск функций
    initializeSpellTooltips();

    // остальные функции (скролл, загрузка подкласса и т.д.) остаются как в оригинале
  });
</script>

<style>
  /* --- Стили только для всплывашки заклинаний --- */
  #spell-tooltip {
    position: absolute;
    z-index: 9999;
    background: var(--card-bg, #1e1e1e);
    color: var(--text, #f5f5f5);
    border: 1px solid var(--card-border, #444);
    border-radius: 0.5rem;
    padding: 1rem;
    max-width: 350px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
    transition: opacity 0.15s ease-in-out;
  }

  #spell-tooltip.hidden {
    display: none;
  }

  #spell-tooltip h3 {
    color: var(--primary, #8cf);
    margin-bottom: 0.5rem;
    font-size: 1.1rem;
  }

  #spell-tooltip p {
    margin-bottom: 0.3rem;
    line-height: 1.4;
  }

  #spell-tooltip div {
    margin-top: 0.5rem;
    font-size: 0.95rem;
    line-height: 1.5;
  }
  .content {
    max-width: 1200px;
    margin: 0 auto;
  }

  .back-link {
    display: inline-block;
    margin-bottom: 2rem;
    color: var(--primary);
    text-decoration: none;
  }

  .back-link:hover {
    text-decoration: underline;
  }

  .class-header {
    margin-bottom: 2rem;
  }

  .name-en {
    color: var(--text);
    opacity: 0.7;
    font-size: 0.8em;
  }

  .source {
    color: var(--text);
    opacity: 0.8;
  }

  .class-description {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .subclass-selector {
    margin-bottom: 1.5rem;
  }

  .subclass-selector select {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--card-border);
    border-radius: 0.25rem;
    background: var(--background);
    color: var(--text);
    font-size: 1rem;
  }

  .lore-content {
    line-height: 1.6;
    margin: 1rem 0;
  }

  .lore-content p {
    margin-bottom: 1rem;
  }

  .lore-content p:last-child {
    margin-bottom: 0;
  }

  .base-lore {
    margin-top: 1.5rem;
    padding: 1rem;
    background: var(--background);
    border-radius: 0.25rem;
  }

  .base-lore summary {
    cursor: pointer;
    color: var(--primary);
  }

  .class-basics {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .basic-info,
  .proficiencies {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .equipment {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .equipment-choice {
    margin-top: 1.5rem;
  }

  .equipment-choice h3 {
    color: var(--primary);
    margin-bottom: 0.5rem;
  }

  .equipment-choice ul {
    list-style-type: disc;
    margin-left: 1.5rem;
  }

  .equipment-choice li {
    margin-bottom: 0.5rem;
  }

  dl {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.5rem 1rem;
    margin-top: 1rem;
  }

  dt {
    font-weight: 600;
    color: var(--primary);
  }

  .feature {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .feature-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
  }

  .feature-header h3 {
    color: var(--primary);
    margin: 0;
    font-size: 1.25rem;
  }

  .feature-level {
    font-size: 0.875rem;
    color: var(--text);
    opacity: 0.8;
    padding: 0.25rem 0.5rem;
    background: var(--background);
    border-radius: 0.25rem;
  }

  .feature-description p {
    margin-bottom: 1rem;
    line-height: 1.6;
  }

  .feature-description p:last-child {
    margin-bottom: 0;
  }

  .collapsible-content {
    margin-top: 1rem;
    border-top: 1px solid var(--card-border);
    padding-top: 1rem;
  }

  .collapsible-item {
    background: var(--background);
    border-radius: 0.5rem;
    margin: 0.5rem 0;
    overflow: hidden;
  }

  .collapsible-item:last-child {
    margin-bottom: 0;
  }

  .collapsible-item summary {
    padding: 0.75rem 1rem;
    cursor: pointer;
    font-weight: 500;
    user-select: none;
  }

  .collapsible-item summary:hover {
    background: var(--nav-hover-bg);
  }

  .collapsible-description {
    padding: 1rem;
    border-top: 1px solid var(--card-border);
    background: var(--card-bg);
  }

  .collapsible-description p {
    margin-bottom: 0.75rem;
    line-height: 1.6;
  }

  .collapsible-description p:last-child {
    margin-bottom: 0;
  }

  .spell-table {
    width: 100%;
    margin: 1rem 0;
    border-collapse: collapse;
    background: var(--card-bg);
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: var(--card-shadow);
  }

  .spell-table th,
  .spell-table td {
    padding: 0.5rem;
    border: 1px solid var(--card-border);
    text-align: left;
  }

  .spell-table th {
    background: var(--background);
    font-weight: 600;
    color: var(--primary);
  }

  .spell-table tbody tr:nth-child(even) {
    background: var(--background);
  }

  .spell-table tbody tr:hover {
    background: var(--nav-hover-bg);
  }

  .spell-table th:first-child {
    border-top-left-radius: 0.5rem;
  }

  .spell-table th:last-child {
    border-top-right-radius: 0.5rem;
  }

  .spell-table tbody tr:last-child td:first-child {
    border-bottom-left-radius: 0.5rem;
  }

  .spell-table tbody tr:last-child td:last-child {
    border-bottom-right-radius: 0.5rem;
  }

  .subclass-feature {
    background: var(--subclass-feature-bg);
    border-color: var(--subclass-feature-border);
  }

  .subclass-feature .feature-header h3 {
    color: var(--subclass-feature-title);
  }

  .subclass-feature .feature-level {
    background: var(--subclass-feature-border);
    color: white;
  }

  .subclass-feature .collapsible-item {
    background: var(--subclass-feature-border);
  }

  .subclass-feature .collapsible-description {
    background: var(--subclass-feature-bg);
  }

  /* Table styling for class abilities */
  .feature-description table,
  .collapsible-description table {
    width: 100%;
    margin: 1rem 0;
    border-collapse: collapse;
    background: var(--card-bg);
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    border: 1px solid var(--card-border);
  }

  .feature-description table th,
  .feature-description table td,
  .collapsible-description table th,
  .collapsible-description table td {
    padding: 0.75rem;
    border: 1px solid var(--card-border);
    text-align: left;
    vertical-align: top;
  }

  .feature-description table th,
  .collapsible-description table th {
    background: var(--primary);
    color: white;
    font-weight: 600;
    font-size: 0.95rem;
  }

  .feature-description table tbody tr,
  .collapsible-description table tbody tr {
    transition: background-color 0.2s ease;
  }

  .feature-description table tbody tr:nth-child(even),
  .collapsible-description table tbody tr:nth-child(even) {
    background: var(--background);
  }

  .feature-description table tbody tr:hover,
  .collapsible-description table tbody tr:hover {
    background: var(--nav-hover-bg);
  }

  .feature-description table th:first-child,
  .collapsible-description table th:first-child {
    border-top-left-radius: 0.5rem;
  }

  .feature-description table th:last-child,
  .collapsible-description table th:last-child {
    border-top-right-radius: 0.5rem;
  }

  .feature-description table tbody tr:last-child td:first-child,
  .collapsible-description table tbody tr:last-child td:first-child {
    border-bottom-left-radius: 0.5rem;
  }

  .feature-description table tbody tr:last-child td:last-child,
  .collapsible-description table tbody tr:last-child td:last-child {
    border-bottom-right-radius: 0.5rem;
  }

  /* Special styling for subclass feature tables */
  .subclass-feature .feature-description table th,
  .subclass-feature .collapsible-description table th {
    background: var(--subclass-feature-title);
    color: white;
  }

  .subclass-feature .feature-description table,
  .subclass-feature .collapsible-description table {
    background: var(--subclass-feature-bg);
    border-color: var(--subclass-feature-border);
  }

  .subclass-feature .feature-description table tbody tr:nth-child(even),
  .subclass-feature .collapsible-description table tbody tr:nth-child(even) {
    background: var(--subclass-feature-border);
    opacity: 0.3;
  }

  /* Scroll to top button */
  .scroll-to-top {
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    width: 3rem;
    height: 3rem;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transition: all 0.3s ease;
    opacity: 0;
    visibility: hidden;
    transform: translateY(20px);
    z-index: 100;
  }

  .scroll-to-top.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
  }

  .scroll-to-top:hover {
    background: var(--primary-dark);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
  }

  .scroll-to-top:active {
    transform: translateY(0);
  }

  /* Responsive table design */
  @media (max-width: 768px) {
    .feature-description table,
    .collapsible-description table {
      font-size: 0.9rem;
    }
    
    .feature-description table th,
    .feature-description table td,
    .collapsible-description table th,
    .collapsible-description table td {
      padding: 0.5rem;
    }
  }
</style>
